<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>ë²½ëŒê¹¨ê¸° ê²Œì„</title>
<style>
  body {
    margin: 0; padding: 0; background: #222; color: #eee; font-family: 'Arial', sans-serif;
    display: flex; flex-direction: column; align-items: center;
  }
  canvas {
    background: #111;
    display: block;
    margin-top: 10px;
    border: 3px solid white;
  }
  #controls {
    margin-top: 12px;
    display: flex;
    justify-content: center;
    flex-wrap: wrap;
    gap: 10px;
  }
  button, select {
    font-size: 14px;
    padding: 8px 12px;
    border-radius: 5px;
    border: none;
    cursor: pointer;
    user-select: none;
  }
  button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  #scoreboard {
    margin-top: 12px;
    display: flex;
    justify-content: center;
    gap: 20px;
    font-size: 16px;
  }
  #mobile-controls {
    margin-top: 15px;
    display: flex;
    justify-content: center;
    gap: 10px;
  }
  .mobile-btn {
    font-size: 25px;
    background: #444;
    color: #eee;
    width: 50px; height: 50px;
    border-radius: 10px;
    user-select: none;
  }
  /* ì•„ì´í…œ íš¨ê³¼ í‘œ ìŠ¤íƒ€ì¼ */
  #itemLegend {
    width: 100%;
    max-width: 600px;
    margin: 20px auto 30px auto;
    font-family: Arial, sans-serif;
    font-size: 14px;
    border-top: 1px solid #ccc;
    padding-top: 10px;
    color: #eee;
  }
  #itemLegend h3 {
    text-align: center;
    margin-bottom: 10px;
  }
  #itemLegend table {
    width: 100%;
    border-collapse: collapse;
    text-align: center;
    background: #333;
    border-radius: 8px;
    overflow: hidden;
  }
  #itemLegend th, #itemLegend td {
    border: 1px solid #666;
    padding: 8px 6px;
  }
</style>
</head>
<body>

<h1>ë²½ëŒê¹¨ê¸° ê²Œì„</h1>

<canvas id="gameCanvas" width="480" height="320"></canvas>

<div id="scoreboard">
  <div id="scoreDisplay">ì ìˆ˜: 0</div>
  <div id="levelDisplay">ë ˆë²¨: 1</div>
  <div id="highScoreDisplay">ìµœê³ ì ìˆ˜ (normal): 0</div>
</div>

<div id="controls">
  <select id="difficultySelect" aria-label="ë‚œì´ë„ ì„ íƒ">
    <option value="easy">Easy</option>
    <option value="normal" selected>Normal</option>
    <option value="hard">Hard</option>
  </select>
  <button id="startBtn">ì‹œì‘í•˜ê¸°</button>
  <button id="restartBtn" disabled>ë‹¤ì‹œí•˜ê¸°</button>
  <button id="bgmToggleBtn">BGM On</button>
</div>

<div id="mobile-controls" aria-label="ëª¨ë°”ì¼ ì¡°ì‘ ë²„íŠ¼">
  <button id="btnLeft" class="mobile-btn" aria-label="ì™¼ìª½ ì´ë™">â—€</button>
  <button id="btnRight" class="mobile-btn" aria-label="ì˜¤ë¥¸ìª½ ì´ë™">â–¶</button>
</div>

<!-- ì•„ì´í…œ íš¨ê³¼ í‘œ -->
<div id="itemLegend" role="region" aria-label="ì•„ì´í…œ ë¬¸ì–‘ë³„ íš¨ê³¼">
  <h3>ì•„ì´í…œ ë¬¸ì–‘ë³„ íš¨ê³¼</h3>
  <table>
    <thead>
      <tr>
        <th>ë¬¸ì–‘</th><th>ì•„ì´í…œ ì´ë¦„</th><th>íš¨ê³¼</th>
      </tr>
    </thead>
    <tbody>
      <tr><td>ğŸŸ¦</td><td>íŒ¨ë“¤ í™•ì¥</td><td>íŒ¨ë“¤ ê¸¸ì´ ì¼ì‹œì  í™•ì¥</td></tr>
      <tr><td>ğŸŸ¥</td><td>íŒ¨ë“¤ ì¶•ì†Œ</td><td>íŒ¨ë“¤ ê¸¸ì´ ì¼ì‹œì  ì¶•ì†Œ</td></tr>
      <tr><td>â­</td><td>ì ìˆ˜ ë³´ë„ˆìŠ¤</td><td>ì ìˆ˜ 100ì  ì¶”ê°€</td></tr>
      <tr><td>ğŸ¢</td><td>ê³µ ì†ë„ ëŠë¦¼</td><td>ê³µ ì†ë„ ì¼ì‹œì  ê°ì†Œ</td></tr>
      <tr><td>ğŸš€</td><td>ê³µ ì†ë„ ë¹ ë¦„</td><td>ê³µ ì†ë„ ì¼ì‹œì  ì¦ê°€</td></tr>
      <tr><td>âš½</td><td>ë©€í‹°ë³¼</td><td>ê³µ 1ê°œ ì¶”ê°€, ë©€í‹°ë³¼ ìœ ì§€</td></tr>
    </tbody>
  </table>
</div>

<script>
(() => {
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");

  // ê²Œì„ ë³€ìˆ˜
  let paddleHeight = 12;
  let paddleWidth = 80;
  let paddleX = (canvas.width - paddleWidth) / 2;

  const ballRadius = 8;

  // ê³µ ë°°ì—´ (ë©€í‹°ë³¼)
  let balls = [];

  let brickRowCount = 4;
  let brickColumnCount = 10;
  const brickWidth = 40;
  const brickHeight = 18;
  const brickPadding = 6;
  const brickOffsetTop = 40;
  const brickOffsetLeft = 0; // ì¤‘ì•™ ê¸°ì¤€ ìœ„ì¹˜ ê³„ì‚°ìœ¼ë¡œ ì¬ì •ì˜ë¨

  // ì ìˆ˜, ë ˆë²¨, ìµœê³ ì ìˆ˜
  let score = 0;
  let level = 1;
  let scoreToNextLevel = 10;

  // ë‚œì´ë„ë³„ ìµœê³ ì ìˆ˜ ì €ì¥
  let highestScores = {easy:0, normal:0, hard:0};
  let currentDifficulty = "normal";

  // ì¡°ì‘ ìƒíƒœ
  let rightPressed = false;
  let leftPressed = false;
  let mobileRight = false;
  let mobileLeft = false;

  // ì•„ì´í…œ ì‹¬ë³¼
  const itemSymbols = {
    paddleExpand: "ğŸŸ¦",
    paddleShrink: "ğŸŸ¥",
    scoreBonus: "â­",
    ballSpeedSlow: "ğŸ¢",
    ballSpeedFast: "ğŸš€",
    ballExtra: "âš½"
  };

  // ì•„ì´í…œ ì§€ì†ì‹œê°„(ms)
  const ITEM_DURATION = 12000;

  // íš¨ê³¼ìŒ ë¡œë“œ
  const hitSound = new Audio("https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg");
  const paddleHitSound = new Audio("https://actions.google.com/sounds/v1/cartoon/metal_thud_and_bounce.ogg");
  const gameOverSound = new Audio("https://actions.google.com/sounds/v1/cartoon/cartoon_boing.ogg");

  // ë°°ê²½ìŒì•… (BGM)
  const bgm = new Audio("https://cdn.pixabay.com/download/audio/2022/02/23/audio_d7d7dd4b7f.mp3?filename=game-background-music-6913.mp3");
  bgm.loop = true;
  bgm.volume = 0.15;

  // DOM ìš”ì†Œ
  const scoreDisplay = document.getElementById("scoreDisplay");
  const levelDisplay = document.getElementById("levelDisplay");
  const highScoreDisplay = document.getElementById("highScoreDisplay");
  const difficultySelect = document.getElementById("difficultySelect");
  const startBtn = document.getElementById("startBtn");
  const restartBtn = document.getElementById("restartBtn");
  const bgmToggleBtn = document.getElementById("bgmToggleBtn");
  const btnLeft = document.getElementById("btnLeft");
  const btnRight = document.getElementById("btnRight");

  // ê²Œì„ ìƒíƒœ í”Œë˜ê·¸
  let isGameStarted = false;
  let isGameOver = false;
  let controlsDisabled = true;

  // íŒ¨ë“¤ í™•ì¥/ì¶•ì†Œ íƒ€ì´ë¨¸
  let paddleExpandTimeout = null;
  let paddleShrinkTimeout = null;

  // ì•„ì´í…œ íš¨ê³¼ ìƒíƒœ
  let itemEffects = {
    paddleExpanded: false,
    paddleShrunk: false,
    ballSpeedModifier: 1,
    scoreBonusActive: false,
    multiBallActive: false
  };

  // ë²½ëŒ ë°°ì—´ (2ì°¨ì›)
  let bricks = [];

  // ê²Œì„ ì´ˆê¸°í™” í•¨ìˆ˜
  function initBricks() {
    bricks = [];
    const canvasCenterX = canvas.width / 2;
    const halfCols = Math.floor(brickColumnCount / 2);
    for(let c=0; c<brickColumnCount; c++) {
      bricks[c] = [];
      for(let r=0; r<brickRowCount; r++) {
        // ì¢Œìš°ëŒ€ì¹­ xì¢Œí‘œ ê³„ì‚°
        let offsetX = 0;
        if(brickColumnCount % 2 === 0) {
          if(c < halfCols) {
            offsetX = canvasCenterX - ((halfCols - c) * (brickWidth + brickPadding)) - brickWidth;
          } else {
            offsetX = canvasCenterX + ((c - halfCols) * (brickWidth + brickPadding));
          }
        } else {
          const centerCol = halfCols;
          if(c === centerCol) {
            offsetX = canvasCenterX - (brickWidth / 2);
          } else if(c < centerCol) {
            offsetX = canvasCenterX - ((centerCol - c) * (brickWidth + brickPadding)) - brickWidth;
          } else {
            offsetX = canvasCenterX + ((c - centerCol) * (brickWidth + brickPadding));
          }
        }
        bricks[c][r] = {
          x: offsetX,
          y: r * (brickHeight + brickPadding) + brickOffsetTop,
          status: 1,
          color: randomColor(),
          item: generateItem() // ì•„ì´í…œ ì—¬ë¶€ ë° ì¢…ë¥˜
        };
      }
    }
  }

  // ë‚œì´ë„ë³„ ì´ˆê¸°ê°’ ì„¸íŒ…
  function setDifficulty(diff) {
    currentDifficulty = diff;
    if(diff === "easy") {
      paddleWidth = 100;
      brickRowCount = 3;
      ballSpeedBase = 2;
      scoreToNextLevel = 10;
    } else if(diff === "normal") {
      paddleWidth = 80;
      brickRowCount = 4;
      ballSpeedBase = 3;
      scoreToNextLevel = 15;
    } else { // hard
      paddleWidth = 60;
      brickRowCount = 5;
      ballSpeedBase = 4;
      scoreToNextLevel = 20;
    }
    paddleX = (canvas.width - paddleWidth) / 2;
    level = 1;
    score = 0;
    updateScoreDisplay();
    updateLevelDisplay();
    updateHighScoreDisplay();
    initBricks();
  }

  // ìƒ‰ìƒ ëœë¤ ì„ íƒ
  function randomColor() {
    const colors = ["#2196F3", "#E91E63", "#9C27B0", "#FF9800", "#4CAF50", "#FFC107", "#00BCD4"];
    return colors[Math.floor(Math.random() * colors.length)];
  }

  // ì•„ì´í…œ ìƒì„± í™•ë¥ ê³¼ ì¢…ë¥˜ ê²°ì • (ì•½ 20% í™•ë¥  ì•„ì´í…œ)
  function generateItem() {
    const chance = Math.random();
    if(chance < 0.20) {
      // 6ì¢…ë¥˜ ì¤‘ í•˜ë‚˜ ëœë¤
      const keys = Object.keys(itemSymbols);
      const selected = keys[Math.floor(Math.random() * keys.length)];
      return selected;
    }
    return null;
  }

  // ê³µ ê°ì²´ ìƒì„± (ì´ˆê¸° ê³µ)
  function createBall() {
    return {
      x: canvas.width / 2,
      y: canvas.height - paddleHeight - ballRadius - 10,
      dx: (Math.random() * 2 + 2) * (Math.random() < 0.5 ? -1 : 1),
      dy: -ballSpeedBase,
      radius: ballRadius,
      speedModifier: 1
    };
  }

  // ê³µ ì†ë„ ê¸°ë³¸ê°’ (ë‚œì´ë„ì— ë”°ë¼ ë‹¬ë¼ì§)
  let ballSpeedBase = 3;

  // ê²Œì„ ì´ˆê¸°í™”
  function initGame() {
    setDifficulty(currentDifficulty);
    balls = [createBall()];
    isGameStarted = false;
    isGameOver = false;
    controlsDisabled = true;
    startBtn.disabled = false;
    restartBtn.disabled = true;
    paddleExpandTimeout && clearTimeout(paddleExpandTimeout);
    paddleShrinkTimeout && clearTimeout(paddleShrinkTimeout);
    itemEffects = {
      paddleExpanded: false,
      paddleShrunk: false,
      ballSpeedModifier: 1,
      scoreBonusActive: false,
      multiBallActive: false
    };
    paddleWidth = paddleWidth; // ë‚œì´ë„ ë”°ë¼ ì„¤ì •ëœ ê°’ ìœ ì§€
    paddleX = (canvas.width - paddleWidth) / 2;
  }

  // ì ìˆ˜, ë ˆë²¨, ìµœê³ ì ìˆ˜ ì—…ë°ì´íŠ¸ í‘œì‹œ
  function updateScoreDisplay() {
    scoreDisplay.textContent = `ì ìˆ˜: ${score}`;
  }
  function updateLevelDisplay() {
    levelDisplay.textContent = `ë ˆë²¨: ${level}`;
  }
  function updateHighScoreDisplay() {
    const hs = highestScores[currentDifficulty] || 0;
    highScoreDisplay.textContent = `ìµœê³ ì ìˆ˜ (${currentDifficulty}): ${hs}`;
  }

  // ì¶©ëŒ ì²´í¬ ë° ì•„ì´í…œ ì ìš©
  function collisionDetection() {
    balls.forEach(ball => {
      for(let c=0; c<brickColumnCount; c++) {
        for(let r=0; r<brickRowCount; r++) {
          const b = bricks[c][r];
          if(b.status === 1) {
            if(ball.x > b.x && ball.x < b.x + brickWidth && ball.y > b.y && ball.y < b.y + brickHeight) {
              ball.dy = -ball.dy;
              b.status = 0;
              hitSound.play();

              // ì•„ì´í…œ ìˆìœ¼ë©´ ì ìš©
              if(b.item) applyItemEffect(b.item);

              // ì ìˆ˜ ì¦ê°€
              score += 5;
              updateScoreDisplay();

              // ë ˆë²¨ì—… ì²´í¬
              if(score >= scoreToNextLevel) {
                level++;
                scoreToNextLevel += 10 + level*5;
                updateLevelDisplay();
                // ë ˆë²¨ì—…ì‹œ ë²½ëŒ ë‹¤ì‹œ ìƒì„± + ë‚œì´ë„ ì‚´ì§ ì¦ê°€
                initBricks();
                // ê³µ ì†ë„ ì¦ê°€ (ìµœëŒ€ 6ë°° ì†ë„)
                balls.forEach(ball => {
                  ball.dy = -Math.min(6, Math.abs(ball.dy) + 0.5) * Math.sign(ball.dy);
                });
              }

              // ëª¨ë“  ë²½ëŒ ë‹¤ ê¹¨ì¡Œì„ ë•Œ ì¬ìƒì„±
              if(allBricksCleared()) {
                initBricks();
              }

              return;
            }
          }
        }
      }
    });
  }

  // ëª¨ë“  ë²½ëŒ ê¹¨ì§ ì²´í¬
  function allBricksCleared() {
    for(let c=0; c<brickColumnCount; c++) {
      for(let r=0; r<brickRowCount; r++) {
        if(bricks[c][r].status === 1) return false;
      }
    }
    return true;
  }

  // ì•„ì´í…œ íš¨ê³¼ ì ìš© í•¨ìˆ˜
  function applyItemEffect(itemKey) {
    switch(itemKey) {
      case "paddleExpand":
        if(itemEffects.paddleExpanded) return;
        itemEffects.paddleExpanded = true;
        paddleWidth = Math.min(canvas.width, paddleWidth * 1.5);
        paddleX = Math.min(paddleX, canvas.width - paddleWidth);
        paddleExpandTimeout && clearTimeout(paddleExpandTimeout);
        paddleExpandTimeout = setTimeout(() => {
          paddleWidth /= 1.5;
          itemEffects.paddleExpanded = false;
        }, ITEM_DURATION);
        break;
      case "paddleShrink":
        if(itemEffects.paddleShrunk) return;
        itemEffects.paddleShrunk = true;
        paddleWidth = Math.max(40, paddleWidth / 1.5);
        paddleShrinkTimeout && clearTimeout(paddleShrinkTimeout);
        paddleShrinkTimeout = setTimeout(() => {
          paddleWidth *= 1.5;
          itemEffects.paddleShrunk = false;
        }, ITEM_DURATION);
        break;
      case "scoreBonus":
        if(itemEffects.scoreBonusActive) return;
        score += 100;
        updateScoreDisplay();
        itemEffects.scoreBonusActive = true;
        setTimeout(() => { itemEffects.scoreBonusActive = false; }, ITEM_DURATION);
        break;
      case "ballSpeedSlow":
        balls.forEach(ball => {
          ball.speedModifier = 0.7;
        });
        itemEffects.ballSpeedModifier = 0.7;
        setTimeout(() => {
          balls.forEach(ball => {
            ball.speedModifier = 1;
          });
          itemEffects.ballSpeedModifier = 1;
        }, ITEM_DURATION);
        break;
      case "ballSpeedFast":
        balls.forEach(ball => {
          ball.speedModifier = 1.3;
        });
        itemEffects.ballSpeedModifier = 1.3;
        setTimeout(() => {
          balls.forEach(ball => {
            ball.speedModifier = 1;
          });
          itemEffects.ballSpeedModifier = 1;
        }, ITEM_DURATION);
        break;
      case "ballExtra":
        if(itemEffects.multiBallActive) return;
        itemEffects.multiBallActive = true;
        if(balls.length < 3) {
          const newBall = createBall();
          newBall.x = balls[0].x;
          newBall.y = balls[0].y;
          newBall.dx = -balls[0].dx;
          balls.push(newBall);
        }
        break;
    }
  }

  // ê³µ ê·¸ë¦¬ê¸°
  function drawBalls() {
    balls.forEach(ball => {
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
      ctx.fillStyle = "#eee";
      ctx.fill();
      ctx.closePath();
    });
  }

  // íŒ¨ë“¤ ê·¸ë¦¬ê¸°
  function drawPaddle() {
    ctx.beginPath();
    ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
    ctx.fillStyle = "#eee";
    ctx.fill();
    ctx.closePath();
  }

  // ë²½ëŒ ê·¸ë¦¬ê¸° (ì•„ì´í…œ ë¬¸ì–‘ í¬í•¨)
  function drawBricks() {
    for(let c=0; c<brickColumnCount; c++) {
      for(let r=0; r<brickRowCount; r++) {
        const b = bricks[c][r];
        if(b.status === 1) {
          ctx.beginPath();
          ctx.rect(b.x, b.y, brickWidth, brickHeight);
          ctx.fillStyle = b.color;
          ctx.fill();
          ctx.closePath();
          // ì•„ì´í…œ ë¬¸ì–‘ í‘œì‹œ
          if(b.item) {
            ctx.font = "18px Arial";
            ctx.fillText(itemSymbols[b.item] || "â“", b.x + brickWidth/2 - 7, b.y + brickHeight - 4);
          }
        }
      }
    }
  }

  // ê²Œì„ ì˜¤ë²„ ì²˜ë¦¬
  function gameOver() {
    if(isGameOver) return;
    isGameOver = true;
    controlsDisabled = true;
    restartBtn.disabled = false;
    gameOverSound.play();
    // ìµœê³ ì ìˆ˜ ì €ì¥
    if(score > highestScores[currentDifficulty]) {
      highestScores[currentDifficulty] = score;
      updateHighScoreDisplay();
    }
    alert(`ê²Œì„ ì¢…ë£Œ! ì ìˆ˜: ${score}`);
  }

  // ê²Œì„ ë£¨í”„
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawBricks();
    drawBalls();
    drawPaddle();
    collisionDetection();

    if(isGameOver) return;

    balls.forEach(ball => {
      // ë²½ ì¶©ëŒ
      if(ball.x + ball.dx * ball.speedModifier > canvas.width - ball.radius || ball.x + ball.dx * ball.speedModifier < ball.radius) {
        ball.dx = -ball.dx;
      }
      if(ball.y + ball.dy * ball.speedModifier < ball.radius) {
        ball.dy = -ball.dy;
      } else if(ball.y + ball.dy * ball.speedModifier > canvas.height - ball.radius - paddleHeight) {
        // íŒ¨ë“¤ ì¶©ëŒ ì²´í¬
        if(ball.x > paddleX && ball.x < paddleX + paddleWidth) {
          paddleHitSound.play();
          ball.dy = -ball.dy;
          // ê³µ ì†ë„ ì¦ê°€ (ìµœëŒ€ 6ë°°)
          ball.dy = -Math.min(6, Math.abs(ball.dy) + 0.1) * Math.sign(ball.dy);

          // ê³µ ì¢Œìš° ë°©í–¥ ë³€í™”, íŒ¨ë“¤ ì¤‘ì•™ ê¸°ì¤€
          let hitPos = (ball.x - paddleX) / paddleWidth;
          ball.dx = (hitPos - 0.5) * 10;
        } else if(ball.y + ball.dy * ball.speedModifier > canvas.height - ball.radius) {
          // ê³µ ë°”ë‹¥ ì¶©ëŒ â†’ ê²Œì„ ì˜¤ë²„
          gameOver();
        }
      }
      ball.x += ball.dx * ball.speedModifier;
      ball.y += ball.dy * ball.speedModifier;
    });

    // íŒ¨ë“¤ ì´ë™
    if(!controlsDisabled) {
      if(rightPressed || mobileRight) {
        paddleX += 7;
        if(paddleX + paddleWidth > canvas.width) {
          paddleX = canvas.width - paddleWidth;
        }
      } else if(leftPressed || mobileLeft) {
        paddleX -= 7;
        if(paddleX < 0) {
          paddleX = 0;
        }
      }
    }

    requestAnimationFrame(draw);
  }

  // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì„¸íŒ…
  document.addEventListener("keydown", e => {
    if(controlsDisabled) return;
    if(e.key === "ArrowRight" || e.key === "d") {
      rightPressed = true;
    } else if(e.key === "ArrowLeft" || e.key === "a") {
      leftPressed = true;
    }
  });
  document.addEventListener("keyup", e => {
    if(e.key === "ArrowRight" || e.key === "d") {
      rightPressed = false;
    } else if(e.key === "ArrowLeft" || e.key === "a") {
      leftPressed = false;
    }
  });

  // ëª¨ë°”ì¼ í„°ì¹˜ ë²„íŠ¼ ì´ë²¤íŠ¸
  leftBtn.addEventListener("touchstart", e => { e.preventDefault(); mobileLeft = true; });
  leftBtn.addEventListener("touchend", e => { e.preventDefault(); mobileLeft = false; });
  rightBtn.addEventListener("touchstart", e => { e.preventDefault(); mobileRight = true; });
  rightBtn.addEventListener("touchend", e => { e.preventDefault(); mobileRight = false; });

  // ì‹œì‘ ë²„íŠ¼
  startBtn.addEventListener("click", () => {
    if(isGameStarted) return;
    isGameStarted = true;
    controlsDisabled = false;
    startBtn.disabled = true;
    restartBtn.disabled = false;
    draw();
  });

  // ë‹¤ì‹œí•˜ê¸° ë²„íŠ¼
  restartBtn.addEventListener("click", () => {
    initGame();
    draw();
  });

  // ë‚œì´ë„ ì„ íƒ ì´ë²¤íŠ¸
  difficultySelect.addEventListener("change", e => {
    setDifficulty(e.target.value);
  });

  // ë°°ê²½ ìŒì•… í† ê¸€
  musicBtn.addEventListener("click", () => {
    if(musicPlaying) {
      backgroundMusic.pause();
      musicPlaying = false;
      musicBtn.textContent = "ìŒì•… ì¼œê¸°";
    } else {
      backgroundMusic.play();
      musicPlaying = true;
      musicBtn.textContent = "ìŒì•… ë„ê¸°";
    }
  });

  // ì´ˆê¸° ì„¤ì •
  initGame();
</script>
</body>
</html>
