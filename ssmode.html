<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>ë²½ëŒê¹¨ê¸° ê²Œì„ with BGM</title>
<style>
  body {
    margin: 0; background: #222; color: #eee; font-family: Arial, sans-serif;
    display: flex; flex-direction: column; align-items: center; height: 100vh;
  }
  canvas {
    border: 2px solid #fff;
    background: #111;
    display: block;
    margin-top: 10px;
  }
  #controls {
    margin-top: 10px;
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    justify-content: center;
    user-select: none;
  }
  button, select {
    padding: 6px 12px;
    font-size: 14px;
    border-radius: 4px;
    border: none;
    cursor: pointer;
    background: #444;
    color: #eee;
    transition: background 0.3s;
  }
  button:disabled, select:disabled {
    background: #222;
    cursor: not-allowed;
    color: #666;
  }
  button:hover:not(:disabled), select:hover:not(:disabled) {
    background: #666;
  }
  #scoreboard {
    margin-top: 10px;
    font-size: 18px;
    display: flex;
    gap: 20px;
  }
  /* ëª¨ë°”ì¼ ì¢Œìš°ë²„íŠ¼ */
  #mobile-buttons {
    margin-top: 10px;
    display: flex;
    gap: 12px;
    justify-content: center;
  }
  .mob-btn {
    width: 60px;
    height: 40px;
    font-size: 18px;
    border-radius: 6px;
    background: #555;
    color: #eee;
    user-select: none;
  }
</style>
</head>
<body>

<h1>ë²½ëŒê¹¨ê¸° ê²Œì„ with BGM</h1>

<div id="scoreboard">
  <div>ì ìˆ˜: <span id="score">0</span></div>
  <div>ìµœê³ ì ìˆ˜: <span id="highscore">0</span></div>
  <div>ë ˆë²¨: <span id="level">1</span></div>
</div>

<canvas id="gameCanvas" width="480" height="320"></canvas>

<div id="controls">
  <select id="difficultySelect" title="ë‚œì´ë„ ì„ íƒ">
    <option value="easy">ì‰¬ì›€</option>
    <option value="normal" selected>ë³´í†µ</option>
    <option value="hard">ì–´ë ¤ì›€</option>
  </select>
  <button id="startBtn" title="ê²Œì„ ì‹œì‘">ì‹œì‘í•˜ê¸°</button>
  <button id="restartBtn" title="ê²Œì„ ë‹¤ì‹œ ì‹œì‘" disabled>ë‹¤ì‹œí•˜ê¸°</button>
  <button id="bgmToggleBtn" title="ë°°ê²½ìŒì•… ON/OFF">BGM ON</button>
</div>

<div id="mobile-buttons">
  <button class="mob-btn" id="btnLeft">â—€</button>
  <button class="mob-btn" id="btnRight">â–¶</button>
</div>

<!-- ë°°ê²½ìŒì•… -->
<audio id="bgm" src="ads/Tetris.mp3" loop preload="auto"></audio>

<!-- íš¨ê³¼ìŒ -->
<audio id="hitSound" src="ads/linebroken1.wav" preload="auto"></audio>
<audio id="gameOverSound" src="ads/linebroken2.wav" preload="auto"></audio>

<script>
(() => {
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");

  const scoreElem = document.getElementById("score");
  const highscoreElem = document.getElementById("highscore");
  const levelElem = document.getElementById("level");
  const difficultySelect = document.getElementById("difficultySelect");
  const startBtn = document.getElementById("startBtn");
  const restartBtn = document.getElementById("restartBtn");
  const btnLeft = document.getElementById("btnLeft");
  const btnRight = document.getElementById("btnRight");
  const bgmToggleBtn = document.getElementById("bgmToggleBtn");

  const hitSound = document.getElementById("hitSound");
  const gameOverSound = document.getElementById("gameOverSound");
  const bgm = document.getElementById("bgm");

  // ê²Œì„ ìƒíƒœ ë³€ìˆ˜
  let score = 0;
  let highscore = localStorage.getItem("brickBreakerHighscore") || 0;
  highscore = Number(highscore);
  let level = 1;
  let isGameOver = false;

  // íŒ¨ë“¤ ë³€ìˆ˜
  let paddleHeight = 10;
  let paddleWidth = 75;
  let paddleX = (canvas.width - paddleWidth) / 2;

  // ê³µë“¤ ë°°ì—´ (ë©€í‹°ë³¼ ì§€ì›)
  let balls = [];

  // ê³µ ê¸°ë³¸ ì†ë„
  let baseSpeed = 3;

  // ì¢Œìš° ì¡°ì‘ ìƒíƒœ
  let rightPressed = false;
  let leftPressed = false;
  let mobileRight = false;
  let mobileLeft = false;

  // ë²½ëŒ ì„¤ì •
  let brickRowCount = 5;
  let brickColumnCount = 7;
  let brickWidth = 55;
  let brickHeight = 20;
  let brickPadding = 7;
  let brickOffsetTop = 30;
  let brickOffsetLeft = 25;

  // ë²½ëŒ ë°°ì—´
  let bricks = [];

  // ì•„ì´í…œ ì¢…ë¥˜
  const ITEM_NONE = 0;
  const ITEM_PADDLE_EXPAND = 1;
  const ITEM_PADDLE_SHRINK = 2;
  const ITEM_SCORE_BONUS = 3;
  const ITEM_BALL_SPEED_SLOW = 4;
  const ITEM_BALL_SPEED_FAST = 5;
  const ITEM_BALL_EXTRA = 6;

  // ì•„ì´í…œ íš¨ê³¼ ì§€ì†ì‹œê°„ (ë°€ë¦¬ì´ˆ)
  const ITEM_DURATION = 10000;

  // í˜„ì¬ í™œì„± ì•„ì´í…œ ìƒíƒœ
  let activeItems = {
    paddleSizeModifier: 0,  // +1 : í™•ì¥, -1 : ì¶•ì†Œ, 0 : ê¸°ë³¸
    ballSpeedModifier: 0,   // +1 : ë¹ ë¦„, -1 : ëŠë¦¼, 0 : ê¸°ë³¸
    ballExtraActive: false, // ë©€í‹°ë³¼ í™œì„± ì—¬ë¶€
    itemTimeouts: []
  };

  // ì•„ì´í…œ ë¸”ë¡ ìƒì„± í™•ë¥  (%)
  const ITEM_BLOCK_CHANCE = 15;

  // ê²Œì„ ì˜¤ë²„ ìƒíƒœ ì‹œ ì»¨íŠ¸ë¡¤ ë¹„í™œì„±í™” í”Œë˜ê·¸
  let controlsDisabled = false;

  // ê²Œì„ ë³´ë” í°ìƒ‰
  canvas.style.border = "2px solid white";

  // ì´ˆê¸° UI ì„¤ì •
  scoreElem.textContent = score;
  highscoreElem.textContent = highscore;
  levelElem.textContent = level;

  // ë²½ëŒ ì´ˆê¸°í™” í•¨ìˆ˜
  function resetBricks() {
    bricks = [];
    for(let c = 0; c < brickColumnCount; c++) {
      bricks[c] = [];
      for(let r = 0; r < brickRowCount; r++) {
        // ì•„ì´í…œ ë¸”ë¡ ëœë¤ ì„¤ì •
        let itemType = ITEM_NONE;
        if(Math.random() * 100 < ITEM_BLOCK_CHANCE) {
          // ì•„ì´í…œ ì¤‘ í•˜ë‚˜ ëœë¤ ì„ íƒ (1~6)
          itemType = Math.floor(Math.random() * 6) + 1;
        }
        bricks[c][r] = {
          x: 0,
          y: 0,
          status: 1,
          color: getRandomBrickColor(),
          item: itemType
        };
      }
    }
  }

  // ë¬´ì‘ìœ„ ë²½ëŒ ìƒ‰ìƒ ì„ íƒ
  function getRandomBrickColor() {
    const colors = [
      "#e74c3c", // red
      "#f39c12", // orange
      "#f1c40f", // yellow
      "#27ae60", // green
      "#2980b9", // blue
      "#8e44ad", // purple
      "#2c3e50"  // dark blue
    ];
    return colors[Math.floor(Math.random() * colors.length)];
  }

  // ì ìˆ˜, ë ˆë²¨, ìµœê³ ì  ì—…ë°ì´íŠ¸
  function updateScoreboard() {
    scoreElem.textContent = score;
    highscoreElem.textContent = highscore;
    levelElem.textContent = level;
  }

  // ë²½ëŒ ê·¸ë¦¬ê¸°
  function drawBricks() {
    for(let c = 0; c < brickColumnCount; c++) {
      for(let r = 0; r < brickRowCount; r++) {
        let b = bricks[c][r];
        if(b.status === 1) {
          let brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
          let brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
          b.x = brickX;
          b.y = brickY;

          ctx.fillStyle = b.color;
          ctx.fillRect(brickX, brickY, brickWidth, brickHeight);

          if(b.item !== ITEM_NONE) {
            ctx.fillStyle = "#fff";
            ctx.font = "bold 16px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            let itemChar = getItemChar(b.item);
            ctx.fillText(itemChar, brickX + brickWidth/2, brickY + brickHeight/2);
          }

          ctx.strokeStyle = "#000";
          ctx.strokeRect(brickX, brickY, brickWidth, brickHeight);
        }
      }
    }
  }

  // ì•„ì´í…œ ì•„ì´ì½˜ í‘œì‹œìš© ë¬¸ì
  function getItemChar(item) {
    switch(item) {
      case ITEM_PADDLE_EXPAND: return "â†”";  // í™•ì¥
      case ITEM_PADDLE_SHRINK: return "â‡";  // ì¶•ì†Œ
      case ITEM_SCORE_BONUS: return "+";
      case ITEM_BALL_SPEED_SLOW: return "ğŸ¢";
      case ITEM_BALL_SPEED_FAST: return "âš¡";
      case ITEM_BALL_EXTRA: return "âš¾";
      default: return "";
    }
  }

  // íŒ¨ë“¤ ê·¸ë¦¬ê¸°
  function drawPaddle() {
    ctx.fillStyle = "#fff";
    ctx.fillRect(paddleX, canvas.height - paddleHeight - 5, paddleWidth, paddleHeight);
  }

  // ê³µ ê·¸ë¦¬ê¸°
  function drawBall(ball) {
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
    ctx.fillStyle = "#ffdd55";
    ctx.fill();
    ctx.closePath();
  }

  // ì¶©ëŒ ê°ì§€ ë° ì²˜ë¦¬
  function collisionDetection() {
    balls.forEach((ball, ballIdx) => {
      for(let c = 0; c < brickColumnCount; c++) {
        for(let r = 0; r < brickRowCount; r++) {
          let b = bricks[c][r];
          if(b.status === 1) {
            if(ball.x > b.x && ball.x < b.x + brickWidth &&
               ball.y > b.y && ball.y < b.y + brickHeight) {
              ball.dy = -ball.dy;

              // ë²½ëŒ ê¹¨ì§
              b.status = 0;
              score += 10;
              if(score > highscore) {
                highscore = score;
                localStorage.setItem("brickBreakerHighscore", highscore);
              }

              hitSound.currentTime = 0;
              hitSound.play();

              // ì•„ì´í…œ ë¸”ë¡ì´ë©´ íš¨ê³¼ ì ìš©
              if(b.item !== ITEM_NONE) {
                applyItemEffect(b.item);
              }

              // ë ˆë²¨ì—… ë° ë²½ëŒ ì¬ìƒì„±
              if(score > level * 100) {
                level++;
                resetBricks();
              }

              // ëª¨ë“  ë²½ëŒ ì œê±° ì‹œ ë‹¤ì‹œ ìƒì„±
              if(isAllBricksCleared()) {
                resetBricks();
              }

              updateScoreboard();
            }
          }
        }
      }
    });
  }

  // ëª¨ë“  ë²½ëŒ ì œê±° ì²´í¬
  function isAllBricksCleared() {
    for(let c = 0; c < brickColumnCount; c++) {
      for(let r = 0; r < brickRowCount; r++) {
        if(bricks[c][r].status === 1) return false;
      }
    }
    return true;
  }

  // ì•„ì´í…œ íš¨ê³¼ ì ìš©
  function applyItemEffect(item) {
    switch(item) {
      case ITEM_PADDLE_EXPAND:
        if(activeItems.paddleSizeModifier !== 1) {
          activeItems.paddleSizeModifier = 1;
          paddleWidth = 110;
          setTimeout(() => {
            if(!isGameOver) {
              activeItems.paddleSizeModifier = 0;
              paddleWidth = 75;
            }
          }, ITEM_DURATION);
        }
        break;
      case ITEM_PADDLE_SHRINK:
        if(activeItems.paddleSizeModifier !== -1) {
          activeItems.paddleSizeModifier = -1;
          paddleWidth = 50;
          if(paddleX + paddleWidth > canvas.width) {
            paddleX = canvas.width - paddleWidth;
          }
          setTimeout(() => {
            if(!isGameOver) {
              activeItems.paddleSizeModifier = 0;
              paddleWidth = 75;
            }
          }, ITEM_DURATION);
        }
        break;
      case ITEM_SCORE_BONUS:
        score += 50;
        if(score > highscore) {
          highscore = score;
          localStorage.setItem("brickBreakerHighscore", highscore);
        }
        break;
      case ITEM_BALL_SPEED_SLOW:
        if(activeItems.ballSpeedModifier !== -1) {
          activeItems.ballSpeedModifier = -1;
          balls.forEach(b => {
            b.dx *= 0.7;
            b.dy *= 0.7;
          });
          setTimeout(() => {
            if(!isGameOver) {
              activeItems.ballSpeedModifier = 0;
              balls.forEach(b => {
                b.dx /= 0.7;
                b.dy /= 0.7;
              });
            }
          }, ITEM_DURATION);
        }
        break;
      case ITEM_BALL_SPEED_FAST:
        if(activeItems.ballSpeedModifier !== 1) {
          activeItems.ballSpeedModifier = 1;
          balls.forEach(b => {
            b.dx *= 1.3;
            b.dy *= 1.3;
          });
          setTimeout(() => {
            if(!isGameOver) {
              activeItems.ballSpeedModifier = 0;
              balls.forEach(b => {
                b.dx /= 1.3;
                b.dy /= 1.3;
              });
            }
          }, ITEM_DURATION);
        }
        break;
      case ITEM_BALL_EXTRA:
        if(!activeItems.ballExtraActive) {
          activeItems.ballExtraActive = true;
          // ê¸°ì¡´ ê³µ ì¤‘ ì²«ë²ˆì§¸ ê³µ ê¸°ì¤€ìœ¼ë¡œ ìƒˆ ê³µ ì¶”ê°€
          let firstBall = balls[0];
          balls.push({
            x: firstBall.x,
            y: firstBall.y,
            dx: -firstBall.dx,
            dy: firstBall.dy,
            radius: firstBall.radius
          });
          // 15ì´ˆ í›„ ë©€í‹°ë³¼ í•´ì œ
          setTimeout(() => {
            if(!isGameOver) {
              activeItems.ballExtraActive = false;
              if(balls.length > 1) balls.pop();
            }
          }, ITEM_DURATION);
        }
        break;
    }
    updateScoreboard();
  }

  // ê³µ ì´ˆê¸°í™”
  function resetBalls() {
    balls = [{
      x: canvas.width/2,
      y: canvas.height - 30,
      dx: baseSpeed * (Math.random() > 0.5 ? 1 : -1),
      dy: -baseSpeed,
      radius: 8
    }];
  }

  // ê²Œì„ ì´ˆê¸°í™”
  function initGame() {
    score = 0;
    level = 1;
    isGameOver = false;
    controlsDisabled = false;
    paddleWidth = 75;
    paddleX = (canvas.width - paddleWidth) / 2;
    activeItems = {
      paddleSizeModifier: 0,
      ballSpeedModifier: 0,
      ballExtraActive: false,
      itemTimeouts: []
    };
    resetBalls();
    resetBricks();
    updateScoreboard();
    restartBtn.disabled = true;
    difficultySelect.disabled = false;
    startBtn.disabled = false;
  }

  // ê³µ ì´ë™ ë° ë²½ê³¼ ì¶©ëŒ ì²˜ë¦¬
  function moveBalls() {
    balls.forEach((ball, idx) => {
      ball.x += ball.dx;
      ball.y += ball.dy;

      // ì¢Œìš° ë²½ ì¶©ëŒ
      if(ball.x + ball.dx > canvas.width - ball.radius || ball.x + ball.dx < ball.radius) {
        ball.dx = -ball.dx;
      }
      // ì²œì¥ ì¶©ëŒ
      if(ball.y + ball.dy < ball.radius) {
        ball.dy = -ball.dy;
      }

      // íŒ¨ë“¤ê³¼ ì¶©ëŒ
      if(ball.y + ball.radius > canvas.height - paddleHeight - 5) {
        if(ball.x > paddleX && ball.x < paddleX + paddleWidth) {
          ball.dy = -ball.dy;

          // íŒ¨ë“¤ ìœ„ì¹˜ì— ë”°ë¥¸ ê³µ ë°©í–¥ ì¡°ì ˆ
          let collidePoint = ball.x - (paddleX + paddleWidth/2);
          collidePoint = collidePoint / (paddleWidth/2);
          let angle = collidePoint * (Math.PI/3); // ìµœëŒ€ 60ë„ ê°ë„ ì¡°ì ˆ

          let speed = Math.sqrt(ball.dx*ball.dx + ball.dy*ball.dy);
          ball.dx = speed * Math.sin(angle);
          ball.dy = -speed * Math.cos(angle);

          hitSound.currentTime = 0;
          hitSound.play();
        } else if(ball.y + ball.dy > canvas.height - ball.radius) {
          // ë°”ë‹¥ì— ë‹¿ìœ¼ë©´ ê²Œì„ ì˜¤ë²„
          if(!isGameOver) {
            gameOver();
          }
        }
      }
    });
  }

  // í‚¤ ë‹¤ìš´ ì´ë²¤íŠ¸
  function keyDownHandler(e) {
    if(controlsDisabled) return;
    if(e.key === "Right" || e.key === "ArrowRight") {
      rightPressed = true;
    } else if(e.key === "Left" || e.key === "ArrowLeft") {
      leftPressed = true;
    }
  }

  // í‚¤ ì—… ì´ë²¤íŠ¸
  function keyUpHandler(e) {
    if(controlsDisabled) return;
    if(e.key === "Right" || e.key === "ArrowRight") {
      rightPressed = false;
    } else if(e.key === "Left" || e.key === "ArrowLeft") {
      leftPressed = false;
    }
  }

  // ëª¨ë°”ì¼ ë²„íŠ¼ í•¸ë“¤ëŸ¬
  btnLeft.addEventListener("touchstart", e => { e.preventDefault(); if(!controlsDisabled) mobileLeft = true; });
  btnLeft.addEventListener("touchend", e => { e.preventDefault(); mobileLeft = false; });
  btnRight.addEventListener("touchstart", e => { e.preventDefault(); if(!controlsDisabled) mobileRight = true; });
  btnRight.addEventListener("touchend", e => { e.preventDefault(); mobileRight = false; });

  // íŒ¨ë“¤ ì´ë™ ì²˜ë¦¬
  function movePaddle() {
    if(rightPressed || mobileRight) {
      paddleX += 7;
      if(paddleX + paddleWidth > canvas.width) {
        paddleX = canvas.width - paddleWidth;
      }
    } else if(leftPressed || mobileLeft) {
      paddleX -= 7;
      if(paddleX < 0) {
        paddleX = 0;
      }
    }
  }

  // ê²Œì„ ì˜¤ë²„ ì²˜ë¦¬
  function gameOver() {
    isGameOver = true;
    controlsDisabled = true;
    gameOverSound.currentTime = 0;
    gameOverSound.play();
    pauseBGM();
    alert("ê²Œì„ ì˜¤ë²„! ì ìˆ˜: " + score);
    restartBtn.disabled = false;
    startBtn.disabled = true;
    difficultySelect.disabled = true;
  }

  // ê²Œì„ ë£¨í”„
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    drawBricks();
    drawPaddle();
    balls.forEach(drawBall);

    collisionDetection();
    moveBalls();
    movePaddle();

    if(!isGameOver) {
      requestAnimationFrame(draw);
    }
  }

  // BGM ì œì–´
  function playBGM() {
    bgm.volume = 0.15;
    bgm.play().catch(() => {});
    bgmToggleBtn.textContent = "BGM OFF";
  }
  function pauseBGM() {
    bgm.pause();
    bgmToggleBtn.textContent = "BGM ON";
  }
  let bgmPlaying = false;

  // BGM í† ê¸€ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
  bgmToggleBtn.addEventListener("click", () => {
    if(bgm.paused) {
      playBGM();
      bgmPlaying = true;
    } else {
      pauseBGM();
      bgmPlaying = false;
    }
  });

  // ë‚œì´ë„ë³„ ì†ë„ ì¡°ì ˆ
  function applyDifficulty() {
    let diff = difficultySelect.value;
    switch(diff) {
      case "easy": baseSpeed = 2; break;
      case "normal": baseSpeed = 3; break;
      case "hard": baseSpeed = 4; break;
      default: baseSpeed = 3;
    }
  }

  // ì‹œì‘ ë²„íŠ¼ í´ë¦­
  startBtn.addEventListener("click", () => {
    if(isGameOver) return;
    initGame();
    applyDifficulty();
    resetBalls();
    draw();
    playBGM();
    bgmPlaying = true;

    startBtn.disabled = true;
    restartBtn.disabled = true;
    difficultySelect.disabled = true;
  });

  // ë‹¤ì‹œí•˜ê¸° ë²„íŠ¼ í´ë¦­
  restartBtn.addEventListener("click", () => {
    if(!isGameOver) return;
    initGame();
    applyDifficulty();
    resetBalls();
    draw();
    playBGM();
    bgmPlaying = true;

    restartBtn.disabled = true;
    startBtn.disabled = true;
    difficultySelect.disabled = true;
  });

  // í‚¤ë³´ë“œ ì´ë²¤íŠ¸ ë“±ë¡
  document.addEventListener("keydown", keyDownHandler);
  document.addEventListener("keyup", keyUpHandler);

  // ì´ˆê¸° ì„¸íŒ…
  updateScoreboard();
  resetBricks();

})();
</script>
</body>
</html>
